---
title: "Group Assignment 10"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Car Sales. Consider the data on used cars with 1436 records and details on 38 attributes, including Price, Age, KM, HP, and other specifications. The goal is to predict the price of a used Toyota Corolla based on its specifications.

```{r}
df = read.csv("ToyotaCorolla.csv")
```

a. Fit a neural network model to the data. Use a single hidden layer with 2 nodes.

```{r}
library(neuralnet)
install.packages("caret")
library(caret)
```

Use predictors Age_08_04, KM, Fuel_Type, HP, Automatic, Doors, Quarterly_Tax, Mfr_Guarantee, Guarantee_Period, Airco, Automatic_airco, CD_Player, Powered_Windows, Sport_Model, and Tow_Bar.

Remember to first scale the numerical predictor and outcome variables to a 0-1 scale (use function preprocess() with method=“range” - see Chapter 7) and convert categorical predictors to dummies.

```{r}
library(nnet)

var = c("Age_08_04", "KM", "Fuel_Type", "HP", "Automatic", "Doors", "Quarterly_Tax", "Mfr_Guarantee", "Guarantee_Period", "Airco", "Automatic_airco", "CD_Player", "Powered_Windows", "Sport_Model", "Tow_Bar")
df.2 = df[,c("Price",var)]

price = df.2[,"Price"]
max_price = range(df.2["Price"])[2]
min_price = range(df.2["Price"])[1]

numerical = c("Price","Age_08_04", "KM","HP","Quarterly_Tax", "Guarantee_Period", "Doors")
norm.values = preProcess(df.2[,numerical], method="range")
df.2[,numerical] = predict(norm.values, df.2[,numerical])
```

```{r}
fuel_types = colnames(class.ind(df.2$Fuel_Type))
df.2 = cbind(df.2, class.ind(df.2$Fuel_Type))
names(df.2) = c("Price", var, paste("Fuel_Type_", fuel_types, sep=""))
df.2 = subset(df.2, select = -c(Fuel_Type))
str(df.2)
```

```{r}
set.seed(2)
train = sample(nrow(df.2), nrow(df.2)*.7)
f = as.formula(paste("Price~", paste(names(df.2)[!names(df.2) %in% c("Price")], collapse ="+")))
nn = neuralnet(f, data = df.2[train,], hidden = 2)
```

Record the RMS error for the training data and the validation data. Repeat the process, changing the number of hidden layers and nodes to {single layer with 5 nodes}, {two layers, 5 nodes in each layer}.

```{r}
compute_rmse = function(nn,df,train,price){
  pred.train = compute(nn, subset(df[train,], select=-c(Price)))
  pred.train.orig = pred.train$net.result*(max_price-min_price) + min_price
  train.rmse = sqrt(mean((price[train]-pred.train.orig)^2))
  pred.test = compute(nn, subset(df[-train,], select=-c(Price)))
  pred.test.orig = pred.test$net.result*(max_price-min_price) + min_price
  test.rmse = sqrt(mean((price[-train]-pred.test.orig)^2))
  rmse=as.data.frame(rbind(train.rmse,test.rmse))
  return(rmse)
}

rmse = compute_rmse(nn, df.2, train, price)
rmse
```

What happens to the RMS error for the training data as the number of layers and nodes increases?

```{r}
nn1 = neuralnet(f, data=df.2[train,], hidden = 5)
rmse1 = compute_rmse(nn1, df.2, train, price)

nn2 = neuralnet(f,data=df.2[train,], hidden = c(5,5))
rmse2 = compute_rmse(nn2, df.2, train, price)
```

What happens to the RMS error for the validation data?

```{r}
rmse_df = cbind(rmse, rmse1, rmse2)
names(rmse_df) = c("1 layer, 2 nodes", "1 layer, 5 nodes", "2 layer, 5 nodes")
rmse_df
```

Comment on the appropriate number of layers and nodes for this application.

The appropriate number of layers and nodes for this application is 2 layers and 5 nodes. This is because this combination has the lowest test.rmse.
